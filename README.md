# Звіт з виконання практичної роботи №4

## Завдання 4.1 – Теоретичне обґрунтування: скільки памʼяті може виділити malloc(3) за один виклик

### Суть завдання:
Зʼясувати максимально можливий обсяг памʼяті, який може бути виділений за один виклик функції malloc.

### Теоретичний аналіз:
Функція malloc(size_t size) очікує як аргумент значення типу size_t. Тип size_t — це беззнакове ціле число, яке використовується для зберігання розмірів та кількостей обʼєктів у байтах. Його максимально можливе значення залежить від архітектури платформи:

  На 32-розрядній (x86) платформі:
size_t має розмір 4 байти, тобто максимальне значення — 2^32 - 1 = 4,294,967,295 байтів (~4 ГБ).

  На 64-розрядній (x86_64) платформі:
size_t має розмір 8 байт, тобто максимальне значення — 2^64 - 1 = 18,446,744,073,709,551,615 байтів (~16 Ебайт).

Проте це теоретична межа, яка на практиці не досягається через низку причин:

### Причини практичного обмеження:
Фізичні ресурси системи:

  Системи зазвичай не мають навіть 1 ТБ оперативної памʼяті, не кажучи про Ебайти.

  Виділення такої кількості памʼяті призведе до помилки ENOMEM.

  Операційна система та політика overcommit:

  У Linux (і FreeBSD подібно) система дозволяє "віртуально" виділяти більше памʼяті, ніж фізично доступно (це називається overcommit).

  Але реальне використання такої памʼяті може призвести до активації OOM Killer (у Linux) або сигналу SIGKILL.

Фрагментація памʼяті та обмеження адресного простору:

  Навіть якщо в системі достатньо віртуального простору, континуальна область для великого блоку може бути недоступною.

  Обмеження ядра або компілятора:

  У деяких системах є штучні обмеження в бібліотеках, наприклад обмеження glibc.

### Чому 8 Ебайт, а не 16?

Попри те, що size_t дозволяє 2⁶⁴-1 (тобто майже 18 Ебайт), вважається, що максимальний обсяг доступної памʼяті для malloc на практиці — 8 Ебайт, оскільки половина адресного простору в 64-бітній архітектурі часто зарезервована:

Одна половина — для ядра, інша — для користувацького простору.

Тому лише 2⁶³ = 8 Ебайт залишаються для користувацьких програм.

## Завдання 4.2 – Що буде, якщо передати malloc(3) від’ємне значення?
### Суть завдання:
Дослідити, як поведеться malloc, якщо передати їй результат арифметичної операції, що призвела до переповнення при множенні цілих чисел зі знаком.

## Код програми:
https://github.com/Masonishche/ASPZ_Pr4/blob/main/task2.c

### Опис:
Не можна передавати відʼємні значення в malloc, оскільки вона приймає size_t — це беззнаковий тип. Якщо обчислення num = xa * xb переповнить int, значення буде некоректно перетворене на великий позитивний size_t, що може викликати помилку або виділення великої кількості памʼяті.

### Результат програми:

![Знімок екрана 2025-06-05 183132](https://github.com/user-attachments/assets/e09463e3-e1e2-42ab-ba70-073c040e1e56)

## Завдання 4.3 – malloc(0)
### Суть завдання:
Дослідити, як malloc(0) поводиться в різних реалізаціях.

### Код програми:
(https://github.com/Masonishche/ASPZ_Pr4/blob/main/task3.c)

### Опис:
Стандарт C дозволяє malloc(0) повертати або NULL, або унікальний непорожній вказівник, який безпечно передавати у free. Потрібно написати тест, перевірити поведінку і проаналізувати її за допомогою ltrace.

### Результат програми:
![image](https://github.com/user-attachments/assets/f3d5e17d-ebc5-42b3-a24a-8d9f890a3eeb)

## Завдання 4.4 – Чи є помилка у фрагменті коду з malloc/free в циклі?
### Суть завдання:
Виявити помилку у циклі з виділенням памʼяті, коли вказівник не скидається в NULL після free.

### Код програми:
https://github.com/Masonishche/ASPZ_Pr4/blob/main/task4.c

### Опис:
У наведеному фрагменті коду є ризик "використання після звільнення" (use-after-free), бо free(ptr) не оновлює ptr. Потрібно написати приклад, який демонструє проблему, і надати правильну реалізацію.

### Результат програми:
![image](https://github.com/user-attachments/assets/f2b36e34-6b51-4ef1-9af7-9a539c6bf874)

## Завдання 4.5 – Що буде, якщо realloc(3) не зможе виділити памʼять?
### Суть завдання:
Перевірити поведінку функції realloc, коли вона не може виділити памʼять.

### Код програми:
https://github.com/Masonishche/ASPZ_Pr4/blob/main/task5.c

### Опис:
Якщо realloc не зможе виділити нову памʼять, вона повертає NULL, але старий блок залишається дійсним. Якщо результат realloc одразу присвоїти старому вказівнику, це може призвести до втрати доступу до памʼяті (memory leak). Потрібно продемонструвати це.

### Результат програми:
![image](https://github.com/user-attachments/assets/66879ea1-949a-4e59-b6f7-d8acc14e9665)

## Завдання 4.6 – realloc з NULL або розміром 0
### Суть завдання:
Вивчити специфіку поведінки realloc, коли перший аргумент — NULL, або другий — 0.

### Код програми:
https://github.com/Masonishche/ASPZ_Pr4/blob/main/task6.c

### Опис:

realloc(NULL, size) поводиться як malloc(size)

realloc(ptr, 0) — поводиться або як free(ptr), або повертає новий вказівник (реалізація-залежне). Потрібно перевірити обидва випадки.

### Результат програми:
![image](https://github.com/user-attachments/assets/794f9886-0c87-425f-b7f9-8531029838a1)

## Завдання 4.7 – Використання reallocarray(3)
### Суть завдання:
Переписати виділення памʼяті з calloc + realloc на reallocarray.

### Код програми:
https://github.com/Masonishche/ASPZ_Pr4/blob/main/task7.c

### Опис:
Функція reallocarray безпечніша за realloc, оскільки враховує можливість переповнення при множенні count * size. Потрібно переписати код з її використанням і порівняти поведінку з ltrace.

### Результат програми:
![image](https://github.com/user-attachments/assets/fcfdff47-ea32-40f0-a2ba-ee913ea73f76)

## Завдання за варіантом 23 – Реалізувати обгортку навколо malloc з журналом
### Суть завдання:
Створити функцію-обгортку навколо malloc, яка буде вести журнал (лог) усіх викликів.

### Код програми:
https://github.com/Masonishche/ASPZ_Pr4/blob/main/task23.c

### Опис:
Потрібно реалізувати власну функцію (наприклад, logged_malloc), яка викликає malloc, записує інформацію про розмір і адресу виділеної памʼяті у файл (наприклад, alloc_log.txt) і повертає вказівник, як звичайний malloc.

### Результат програми:


